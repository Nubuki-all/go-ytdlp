// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// Code generated by cmd/codegen. DO NOT EDIT.

package ytdlp

import (
    "encoding/json"
    "errors"
    "fmt"
    "slices"
)

{{- define "flag-type" -}}
    {{- $option := . -}}
    {{- if (eq $option.NArgs 0) -}}
        bool
    {{- else if (eq $option.NArgs 1) -}}
        {{ if $option.Choices }}{{ $option.Name | to_camel }}Option{{ else }}{{ $option.Type }}{{ end }}
    {{- else if (gt $option.NArgs 1) -}}
        Flag{{ $option.Name | to_camel }}
    {{- end -}}
{{- end -}}{{/* end define flag-type */}}

{{- define "flag-jsonschema" -}}
    {{- $option := . -}}
    jsonschema:"{{"" -}}
        {{- range $choice := $option.Choices -}}
            enum={{ $choice }},
        {{- end -}}
        title={{ $option.Name | to_camel }}
    {{- ""}}"
    {{- " " -}}
    jsonschema_extras:"uid={{ $option.ID }}"
    {{- " " -}}
    jsonschema_description:{{ $option.Help | quote }}
{{- end -}}{{/* end define flag-jsonschema */}}

{{- /* flag config, which is the entrypoint for all flag groups, validating everything, etc. */}}
// FlagConfig holds all information for the flags in which to use for yt-dlp. Note that
// you can technically set multiple conflicting flags through this type, however, when
// the [FlagConfig.Validate] method is called, it will return a [ErrMultipleJSONParsingFlags]
// error if there are any conflicts.
type FlagConfig struct {
    {{ range $group := .OptionGroups }}
        {{ $group.Name | to_camel }} Flags{{ $group.Name | to_camel }} `json:"{{ $group.Name | to_snake }},omitempty,omitzero" jsonschema:"title=Group {{ $group.Name | to_camel }}"`
    {{- end }}{{/* end range for option groups */}}
}

// Clone returns a copy of the flag config.
func (f *FlagConfig) Clone() *FlagConfig {
    // This panics if the flag config is invalid, which is a programming error, as there should be
    // no reason the config can have non-serializable values.
    v := &FlagConfig{}
    b, err := json.Marshal(f)
    if err != nil {
        panic(err)
    }
    err = json.Unmarshal(b, v)
    if err != nil {
        panic(err)
    }
    return v
}

// Validate runs validation across all flag groups. If there are validation-specific
// errors, they will be returned as a [ErrMultipleJSONParsingFlags] error. Otherwise,
// any other errors will be returned as a regular wrapped errors.
func (f *FlagConfig) Validate() error {
    errs := []error{
        {{- range $group := .OptionGroups }}
            f.{{ $group.Name | to_camel }}.Validate(),
        {{- end }}{{/* end range for option groups */}}
    }

    var regularErrs []error
    var validationErrs []*ErrJSONParsingFlag

    for _, err := range errs {
        if err == nil {
            continue
        }
        if verr, ok := IsJSONParsingFlagError(err); ok {
            validationErrs = append(validationErrs, verr)
        } else {
            regularErrs = append(regularErrs, err)
        }
    }

    if len(validationErrs) > 0 {
        return &ErrMultipleJSONParsingFlags{Errors: validationErrs}
    }
    if len(regularErrs) > 0 {
        return errors.Join(regularErrs...)
    }
    return nil
}

func (f *FlagConfig) ToFlags() (flags Flags) {
    {{- range $group := .OptionGroups }}
        flags = append(flags, f.{{ $group.Name | to_camel }}.ToFlags()...)
    {{- end }}{{/* end range for option groups */}}

    // Deduplicate flags by their ID, where only the last one is kept, and the others are deleted.
    for i := 0; i < len(flags); i++ {
        if flags[i].AllowsMultiple {
            continue
        }

        for j := i + 1; j < len(flags); j++ {
            if flags[j].AllowsMultiple {
                continue
            }

            if flags[i].ID == flags[j].ID {
                flags[j] = nil
                flags = append(flags[:j], flags[j+1:]...)
            }
        }
    }
    return flags
}

{{- /*
    flag groups, which are the entrypoint for all flags in a group, validating
    everything, etc.
*/}}
{{ range $group := .OptionGroups }}
type Flags{{ $group.Name | to_camel }} struct {
{{- range $option := .Options -}}
    {{- if $option.Executable -}}{{ continue }}{{- end }}
    {{- if $option.Help }}
        // {{ wrap 90 $option.Help | replace "\n" "\n// " }}
    {{- end }}
    {{ $option.Name | to_camel }}
    {{- " " }}
    {{- if $option.AllowsMultiple }}[]{{ end }}
    {{- if (or (not $option.AllowsMultiple) (gt $option.NArgs 1)) }}*{{ end }}
    {{- template "flag-type" $option }}
    {{- " " }}`json:"{{ $option.Name | to_snake }},omitempty" id:{{ $option.ID | quote }} {{ template "flag-jsonschema" $option }}`
{{- end }}{{/* end range for options */}}
}

{{- /* individual flag structs for flags that can't be represented by a single type. */}}
{{ range $option := .Options -}}
    {{- if (gt $option.NArgs 1) -}}
    type Flag{{ $option.Name | to_camel }} struct {
        {{ range $arg := $option.ArgNames }}
            {{ $arg | to_camel }} {{ $option.Type }} `json:"{{ $arg | to_snake }},omitempty" {{ template "flag-jsonschema" $option }}`
        {{- end }}{{/* end range for args */}}
    }
    {{- end }}{{/* end if nargs */}}
{{ end }}{{/* end range for options */}}

// Validate ensures all flags have appropriate values. If there are validation-specific
// errors, they will be returned as a [ErrMultipleJSONParsingFlags] error.
func (g *Flags{{ $group.Name | to_camel }}) Validate() error {
    if g == nil {
        return nil
    }

    var validationErrs []*ErrJSONParsingFlag
    {{- range $option := .Options -}}
        {{- if $option.Executable }}{{ continue }}{{ end }}

        {{- if $option.Choices }}
        if g.{{ $option.Name | to_camel }} != nil {
            if !slices.Contains(All{{ $option.Name | to_camel }}Options, *g.{{ $option.Name | to_camel }}) {
                validationErrs = append(validationErrs, &ErrJSONParsingFlag{
                    JSONPath: "{{ $group.Name | to_snake }}.{{ $option.Name | to_snake }}",
                    Flag: {{ $option.Flag | quote }},
                    ID: {{ $option.ID | quote }},
                    Err: fmt.Errorf(
                        "invalid value for {{ $group.Name | to_snake }}.{{ $option.Name | to_snake }}: %q (expected one of: %v)",
                        *g.{{ $option.Name | to_camel }},
                        All{{ $option.Name | to_camel }}Options,
                    ),
                })
            }
        }
        {{- end }}
    {{- end }}{{/* end range for options */}}

    {{/* check for duplicates */}}
    duplicates := g.ToFlags().Duplicates()
    for _, duplicate := range duplicates {
        validationErrs = append(validationErrs, &ErrJSONParsingFlag{
            JSONPath: "{{ $group.Name | to_snake }}." + duplicate.ID,
            Flag: duplicate.Flag,
            ID: duplicate.ID,
            Err: fmt.Errorf("duplicate flag (with conflicting ID %q) found: %v", duplicate.ID, duplicate.Flag),
        })
    }

    if len(validationErrs) > 0 {
        return &ErrMultipleJSONParsingFlags{Errors: validationErrs}
    }
    return nil
}

// ToFlags returns the generated flags based off the provided configuration. [Flags{{ $group.Name | to_camel }}.Validate]
// should be called first.
func (g *Flags{{ $group.Name | to_camel }}) ToFlags() (flags Flags) {
    if g == nil {
        return flags
    }

    {{- range $option := .Options -}}
        {{- if $option.Executable }}{{ continue }}{{ end }}
        {{- if $option.AllowsMultiple }}
            for _, v := range g.{{ $option.Name | to_camel }} {
                flags = append(flags, &Flag{
                    {{- ""}}ID: {{ $option.ID | quote }},
                    {{- ""}}Flag: {{ $option.Flag | quote }},
                    {{- ""}}AllowsMultiple: true,
                    {{- ""}}Args:
                    {{- if (eq $option.NArgs 1) }}
                        {{- if $option.Choices }}
                            []any{string(v)},
                        {{- else }}
                            []any{v},
                        {{- end }}
                    {{- else if (gt $option.NArgs 1) }}
                    []any{
                        {{- range $arg := $option.ArgNames -}}
                        v.{{ $arg | to_camel }},
                        {{- end }}
                    }
                    {{- end }}
                {{- ""}}})
            }
        {{- else }}
            if g.{{ $option.Name | to_camel }} != nil {{ if (eq $option.NArgs 0) }} && *g.{{ $option.Name | to_camel }}{{ end }} {
                flags = append(flags, &Flag{
                    {{- ""}}ID: {{ $option.ID | quote }},
                    {{- ""}}Flag: {{ $option.Flag | quote }},
                    {{- ""}}Args:
                        {{- if (eq $option.NArgs 0) }}
                        nil,
                        {{- else if (eq $option.NArgs 1) }}
                            {{- if $option.Choices }}
                                []any{string(*g.{{ $option.Name | to_camel }})},
                            {{- else }}
                                []any{*g.{{ $option.Name | to_camel }}},
                            {{- end }}
                        {{- else if (gt $option.NArgs 1) }}
                        []any{
                            {{- range $arg := $option.ArgNames }}
                            (*g.{{ $option.Name | to_camel }}).{{ $arg | to_camel }},
                            {{- end }}
                        },
                        {{- end }}
                {{- ""}}})
            }
        {{- end }}
    {{- end }}{{/* end range for options */}}
    return flags
}
{{ end }}{{/* end range for option groups */}}
