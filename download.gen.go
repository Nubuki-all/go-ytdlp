// Copyright (c) Liam Stanley <me@liamstanley.io>. All rights reserved. Use
// of this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// Code generated by cmd/codegen. DO NOT EDIT.
//
// Download Option Group

package ytdlp

import (
	"strconv"
)

type DownloadBuilder struct {
	parent *Command
}

// Then jumps back to the base command builder, if you want to add additional flags
// from another flag builder.
func (ff *DownloadBuilder) Then() *Command {
	return ff.parent
}

// Number of fragments of a dash/hlsnative video that should be downloaded
// concurrently (default is %default)
//
// ConcurrentFragments maps to cli flags: -N/--concurrent-fragments=N.
func (ff *DownloadBuilder) ConcurrentFragments(n int) *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "concurrent_fragment_downloads",
		Flag: "--concurrent-fragments",
		Args: []string{
			strconv.Itoa(n),
		},
	})
	return ff
}

// Maximum download rate in bytes per second, e.g. 50K or 4.2M
//
// LimitRate maps to cli flags: -r/--limit-rate/--rate-limit=RATE.
func (ff *DownloadBuilder) LimitRate(rate string) *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "ratelimit",
		Flag: "--limit-rate",
		Args: []string{rate},
	})
	return ff
}

// Minimum download rate in bytes per second below which throttling is assumed and
// the video data is re-extracted, e.g. 100K
//
// ThrottledRate maps to cli flags: --throttled-rate=RATE.
func (ff *DownloadBuilder) ThrottledRate(rate string) *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "throttledratelimit",
		Flag: "--throttled-rate",
		Args: []string{rate},
	})
	return ff
}

// Number of retries (default is %default), or "infinite"
//
// Retries maps to cli flags: -R/--retries=RETRIES.
func (ff *DownloadBuilder) Retries(retries string) *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "retries",
		Flag: "--retries",
		Args: []string{retries},
	})
	return ff
}

// Number of times to retry on file access error (default is %default), or
// "infinite"
//
// FileAccessRetries maps to cli flags: --file-access-retries=RETRIES.
func (ff *DownloadBuilder) FileAccessRetries(retries string) *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "file_access_retries",
		Flag: "--file-access-retries",
		Args: []string{retries},
	})
	return ff
}

// Number of retries for a fragment (default is %default), or "infinite" (DASH,
// hlsnative and ISM)
//
// FragmentRetries maps to cli flags: --fragment-retries=RETRIES.
func (ff *DownloadBuilder) FragmentRetries(retries string) *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "fragment_retries",
		Flag: "--fragment-retries",
		Args: []string{retries},
	})
	return ff
}

// Skip unavailable fragments for DASH, hlsnative and ISM downloads (default)
// (Alias: --no-abort-on-unavailable-fragments)
//
// SkipUnavailableFragments maps to cli flags: --skip-unavailable-fragments/--no-abort-on-unavailable-fragments.
func (ff *DownloadBuilder) SkipUnavailableFragments() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "skip_unavailable_fragments",
		Flag: "--skip-unavailable-fragments",
		Args: nil,
	})
	return ff
}

// Abort download if a fragment is unavailable (Alias:
// --no-skip-unavailable-fragments)
//
// AbortOnUnavailableFragments maps to cli flags: --abort-on-unavailable-fragments/--no-skip-unavailable-fragments.
func (ff *DownloadBuilder) AbortOnUnavailableFragments() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "skip_unavailable_fragments",
		Flag: "--abort-on-unavailable-fragments",
		Args: nil,
	})
	return ff
}

// Keep downloaded fragments on disk after downloading is finished
//
// KeepFragments maps to cli flags: --keep-fragments.
func (ff *DownloadBuilder) KeepFragments() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "keep_fragments",
		Flag: "--keep-fragments",
		Args: nil,
	})
	return ff
}

// Delete downloaded fragments after downloading is finished (default)
//
// NoKeepFragments maps to cli flags: --no-keep-fragments.
func (ff *DownloadBuilder) NoKeepFragments() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "keep_fragments",
		Flag: "--no-keep-fragments",
		Args: nil,
	})
	return ff
}

// Size of download buffer, e.g. 1024 or 16K (default is %default)
//
// BufferSize maps to cli flags: --buffer-size=SIZE.
func (ff *DownloadBuilder) BufferSize(size string) *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "buffersize",
		Flag: "--buffer-size",
		Args: []string{size},
	})
	return ff
}

// The buffer size is automatically resized from an initial value of --buffer-size
// (default)
//
// ResizeBuffer maps to cli flags: --resize-buffer.
func (ff *DownloadBuilder) ResizeBuffer() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "noresizebuffer",
		Flag: "--resize-buffer",
		Args: nil,
	})
	return ff
}

// Do not automatically adjust the buffer size
//
// NoResizeBuffer maps to cli flags: --no-resize-buffer.
func (ff *DownloadBuilder) NoResizeBuffer() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "noresizebuffer",
		Flag: "--no-resize-buffer",
		Args: nil,
	})
	return ff
}

// Size of a chunk for chunk-based HTTP downloading, e.g. 10485760 or 10M (default
// is disabled). May be useful for bypassing bandwidth throttling imposed by a
// webserver (experimental)
//
// HttpChunkSize maps to cli flags: --http-chunk-size=SIZE.
func (ff *DownloadBuilder) HttpChunkSize(size string) *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "http_chunk_size",
		Flag: "--http-chunk-size",
		Args: []string{size},
	})
	return ff
}

// Test sets the "test" flag to "true".
//
// Test maps to cli flags: --test.
func (ff *DownloadBuilder) Test() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "test",
		Flag: "--test",
		Args: nil,
	})
	return ff
}

// PlaylistReverse sets the "playlist-reverse" flag to "true".
//
// PlaylistReverse maps to cli flags: --playlist-reverse.
func (ff *DownloadBuilder) PlaylistReverse() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "playlist_reverse",
		Flag: "--playlist-reverse",
		Args: nil,
	})
	return ff
}

// NoPlaylistReverse sets the "no-playlist-reverse" flag to "false".
//
// NoPlaylistReverse maps to cli flags: --no-playlist-reverse.
func (ff *DownloadBuilder) NoPlaylistReverse() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "playlist_reverse",
		Flag: "--no-playlist-reverse",
		Args: nil,
	})
	return ff
}

// Download playlist videos in random order
//
// PlaylistRandom maps to cli flags: --playlist-random.
func (ff *DownloadBuilder) PlaylistRandom() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "playlist_random",
		Flag: "--playlist-random",
		Args: nil,
	})
	return ff
}

// Process entries in the playlist as they are received. This disables n_entries,
// --playlist-random and --playlist-reverse
//
// LazyPlaylist maps to cli flags: --lazy-playlist.
func (ff *DownloadBuilder) LazyPlaylist() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "lazy_playlist",
		Flag: "--lazy-playlist",
		Args: nil,
	})
	return ff
}

// Process videos in the playlist only after the entire playlist is parsed
// (default)
//
// NoLazyPlaylist maps to cli flags: --no-lazy-playlist.
func (ff *DownloadBuilder) NoLazyPlaylist() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "lazy_playlist",
		Flag: "--no-lazy-playlist",
		Args: nil,
	})
	return ff
}

// Set file xattribute ytdl.filesize with expected file size
//
// XattrSetFilesize maps to cli flags: --xattr-set-filesize.
func (ff *DownloadBuilder) XattrSetFilesize() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "xattr_set_filesize",
		Flag: "--xattr-set-filesize",
		Args: nil,
	})
	return ff
}

// HlsPreferNative sets the "hls-prefer-native" flag to "true".
//
// HlsPreferNative maps to cli flags: --hls-prefer-native.
func (ff *DownloadBuilder) HlsPreferNative() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "hls_prefer_native",
		Flag: "--hls-prefer-native",
		Args: nil,
	})
	return ff
}

// HlsPreferFfmpeg sets the "hls-prefer-ffmpeg" flag to "false".
//
// HlsPreferFfmpeg maps to cli flags: --hls-prefer-ffmpeg.
func (ff *DownloadBuilder) HlsPreferFfmpeg() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "hls_prefer_native",
		Flag: "--hls-prefer-ffmpeg",
		Args: nil,
	})
	return ff
}

// Use the mpegts container for HLS videos; allowing some players to play the video
// while downloading, and reducing the chance of file corruption if download is
// interrupted. This is enabled by default for live streams
//
// HlsUseMpegts maps to cli flags: --hls-use-mpegts.
func (ff *DownloadBuilder) HlsUseMpegts() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "hls_use_mpegts",
		Flag: "--hls-use-mpegts",
		Args: nil,
	})
	return ff
}

// Do not use the mpegts container for HLS videos. This is default when not
// downloading live streams
//
// NoHlsUseMpegts maps to cli flags: --no-hls-use-mpegts.
func (ff *DownloadBuilder) NoHlsUseMpegts() *DownloadBuilder {
	ff.parent.addFlag(&Flag{
		ID:   "hls_use_mpegts",
		Flag: "--no-hls-use-mpegts",
		Args: nil,
	})
	return ff
}
